const { getRandomId, getTableName, getYearMonthRandomId } = require("../utils");
const config = require("../config.json");
const _ = require("underscore");
const getInfo = require("../common");
const commonClass = require("./common.class");
const findTableAndJoinClass = require("./findTableAndJoin.class");
const jobTimerClass = require("./jobTimers.class");
const dropCardClass = require("./dropCards.class");
const trackClass = require("./track.class");
const godBotClass = require("./godBot.class"); //common functions
const cardCommonClass = require("./cardCommon.class");
const pickCardClass = require("./pickCard.class");
const finishClass = require("./finishCard.class");
const declareClass = require("./declareCard.class");
const throwCardClass = require("./throwCard.class");
const logger = require("../utils/logger");
const { GetConfig } = require("../connections/mongodb");
const scheduler = require("../scheduler");
const { DELAY_DECLARE, ROBOT_FINISH } = require("../constants/eventName");
const { addQueue } = require("../scheduler/bullQueue");

const generateRobot = async (cb) => {
  /* +-------------------------------------------------------------------+
      desc:function to generate robot
      i/p: cb = calllback function
      o/p: robot id
    +-------------------------------------------------------------------+ */
  try {
    const { INITIAL_CHIPS, BUCKET_URL } = GetConfig();
    let pp = BUCKET_URL + "prithvi_rummy/4.png";
    const userAvatar = await db
      .collection("user_avatar")
      .aggregate([{ $match: { use: true } }, { $sample: { size: 1 } }])
      .toArray();

    if (userAvatar.length) {
      pp = userAvatar[0].user_avatar;
    }
    logger.info("generateRobot---------------->>>>>pp: " + pp);
    let botName = await db
      .collection("bot_name")
      .aggregate([
        {
          $match: {
            isUsed: {
              $ne: true,
            },
          },
        },
        {
          $limit: 1,
        },
      ])
      .toArray();
    if (botName.length) {
      botName = botName[0];
      let t = {
        un: botName.name, //username
        unId: botName._id, //username id
        unique_id: await getYearMonthRandomId(6, "game_users", "unique_id"), //user uniqueID
        ue: "", //useremail
        pp: pp, //profile picture
        tId: "",
        cd: new Date(), //create date
        det: "", //device type
        dids: [], //device ids
        sn: [], //serial numbe(only for ios)
        wc: 0, //chips for winner
        Chips: config.INITIAL_CHIPS, //user chips
        // bonuscash: 10000,
        // wincash: 20000,
        // depositcash: 10000,
        totalcash: 40000,
        winCash: 0,
        lossCash: 0,
        counters: {
          hw: 0, //hands win
          hwc: 0, //hands win cash mode
          hl: 0, //hands lost
          hlc: 0, // hands lost cash
          hd: 0, //Hands dropped
          hdc: 0, //Hands drop cash
          cw: 0, //consecutive win
          cl: 0, //consecutive lose
          cdr: 0, //consecutive drop
          thp: 0, //Total Hands played
          hpc: 0, //Total hands play cash
          hp: 0, //10 hands play for level tracking
          thpcd: 0, //Total hands play counter in 1 day
          pprc: 0, //play point rummy counter in 1 day
          pplrc: 0, //play pool rummy counter in 1 day
          pdrc: 0, //play deal rummy counter in 1 day
          pbrc: 0, //play bet rummy counter in 1 day
          ptc: 0, //play turnament counter in 1 day
          hcl: INITIAL_CHIPS, //highest chip level
          mcw: 0, //Most Chips Won
          deal_c: 0, //deal mode help session counter
          pool_c: 0, //pool mode help session counter
          bet_c: 0, //bet mode help session counter
          tssc: 0, //total sunny shot claimed counter
          lvc: 0, // level completed counter
          ppo: 0, // current level point
          pper: 0, //current level completed percentage
          opc: 0, // operation counter
          playDays: 0, //consicutive play days
        },
        nwt: "", //network
        lc: commonClass.GetLanguageCode(), //Language code
        rfc: commonClass.GetRandomString(7), //referral code generated by system on signup
        flags: {
          _ir: 1, //is robot
          _isup: 0, //is suspended
          _isbkip: 0, // block by ip
          _isbkdv: 0, // block by device
          _isRated: 0, //is app rated
          _io: 1, //is Online
          _ftpo: 1, //first time offers
          _mhp: 0, // most highest payment
          _pyr: 0, //is payer : 0 / 1
          _cdb: 0, //collect daily bonus
          _noti: 0, //notification : 0 / 1
          _snd: 0, // sounds : 0 / 1
          _vib: 0, //vibration : 0 / 1
          _challenge: 0, //challange : 0 / 1
          _tutf: 1, //tutorial flag
          _payer: 0, //is payer : 0 / 1
        },
        lasts: {
          pl: new Date(), //previous login
          ll: new Date(), //last login
          lpt: new Date(),
          ldt: "", //last device type
          ldi: null, // last device id
          lsn: null, // last serial number
          lfp: "", //last facebook post
          ldbt: new Date(), //last daily bonus time
          lict: new Date(), //last image collect time
          lsct: new Date(), //last lucky spin collect time
          lort: "", //last offer reject time
          lsi: 0, //last bonus index (user in magic box bonus)
          lssct: new Date(),
        },
        s: "free",
        club: "Bronze-I",
        wintrigger: 0, // wintrigger
        losscounter: 0, //loss counter
        friends: [], //array of friends ids
        blocks: [], //array of block user ids
        frndId: "", //friends id
        rand: Math.random(), //random numer for special purposes
        tbid: "", //table id,
        rejoinID: "", //rejoinId
        rejoin: 0, //rejoin flag
        cbtn: 1, //in game notification
        dbf: false, //daily bonus display in user setting or not
        ds: "", //download source
        country: "India", //country of player (default India)
        cc: "in", //country code
        bv: 50, // boot value of table that last played by user
        sck: "", //socket id of user
        sessId: 0, //Session Id
        osType: "", //os of device
        osVer: "", //os version
        devBrnd: "", //device brand
        devMdl: "", //device model
        artifact: {}, //collected artifact
      };
      logger.info("generateRobot---------------->>>>t: ", t);
      db.collection("game_users").insertOne(t, async function (err, resp) {
        let rbid = "";
        if (resp && resp.ops && resp.ops.length > 0) {
          rbid = resp.ops[0]._id.toString();
          logger.info('generateRobot------------>>>>"newid: "' + rbid);
        }
        await db
          .collection("bot_name")
          .findOneAndUpdate(
            { _id: botName._id },
            { $set: { isUsed: true } },
            { new: true }
          );
        if (typeof cb != "undefined") {
          cb(rbid);
        }
      });
    } else {
      logger.info("All robot name is used ðŸ˜‚ðŸ¤£ðŸ˜… ðŸ˜‚ðŸ¤£ðŸ˜… ðŸ˜‚ðŸ¤£ðŸ˜…");
    }
  } catch (error) {
    logger.error("-----> error generateRobot", error);
    getInfo.exceptionError(error);
  }
};
const putRobotOnSeat = (tbId) => {
  /* +-------------------------------------------------------------------+
    desc:function to put robot on seat
    i/p: tbId = table id 
  +-------------------------------------------------------------------+ */
  try {
    const { MAX_DEADWOOD_PTS } = GetConfig();
    getInfo.GetTbInfo(
      tbId,
      {
        pi: 1,
        ap: 1,
        bv: 1,
        mode: 1,
        ms: 1,
        gt: 1,
        stdP: 1,
        game_id: 1,
        sub_id: 1,
        RobotCount: 1,
        HumanCount: 1,
        spcSi: 1,
        _ip: 1,
        minS: 1,
        fromRematch: 1,
      },
      async function (table) {
        if (!table) {
          logger.info(
            'putRobotOnSeat:::::::::::::>>>>Error: "table not found!!!"'
          );
          return false;
        }

        if (table.fromRematch) {
          return false;
        }

        if (table._ip == 1) {
          //means table is private so no robot is required
          logger.info('putRobotOnSeat::::::::::::::>>>>>"table is private"');
          return false;
        }
        let pi = getInfo.getPlayingUserInRound(table.pi);
        logger.info("putRobotOnSeat------->>>>pi: ", pi);
        let rCount = 0,
          uCount = 0;
        let uids = [];
        let pps = [];
        for (let x in pi) {
          if (pi[x]._ir == 1) {
            rCount++;
          } else if (pi[x]._ir == 0) {
            uCount++;
          }

          if (pi[x].uid && pi[x].uid != "") {
            uids.push(getInfo.MongoID(pi[x].uid));
            pps.push(pi[x].pp);
          }
        }
        let chip;
        if (table.gt == "Deal") {
          //robot validation for deal rummy

          chip = table.bv;
          let MIN_SEAT_TO_FILL_DEAL = table.minS;

          if (table.ap >= MIN_SEAT_TO_FILL_DEAL || table.ap == table.ms) {
            logger.info(
              "\nputRobotOnSeat------------" +
              table._id.toString() +
              "------------>>>>table.ap: " +
              table.ap +
              " table.ms: " +
              table.ms
            );
            logger.info(
              "\nputRobotOnSeat--------------" +
              table._id.toString() +
              '---------->>>>Msg: "no need to put robots!!!"'
            );
            return false;
          }
        } else if (table.gt == "Pool") {
          //robot validation for pool rummy

          chip = table.bv;
          let MIN_SEAT_TO_FILL_POOL = table.minS;

          if (
            table.ms == 6 &&
            table.mode == "cash" &&
            table.ap == MIN_SEAT_TO_FILL_POOL &&
            uCount == 2
          ) {
            MIN_SEAT_TO_FILL_POOL = MIN_SEAT_TO_FILL_POOL + 1;
          }

          /* if (table.ap >= MIN_SEAT_TO_FILL_POOL || table.ap == table.ms) {
            logger.info(
              "\nputRobotOnSeat------------" +
                table._id.toString() +
                "-------------->>>>>>table.ap: " +
                table.ap +
                " table.ms: " +
                table.ms
            );
            logger.info(
              "\nputRobotOnSeat--------------" +
                table._id.toString() +
                '---------->>>>Msg: "no need to put robots!!!"'
            );
            return false;
          } */
        } else {
          //robot validation for classic rummy

          chip = table.bv * MAX_DEADWOOD_PTS;
          chip = chip * 3;
          let MIN_SEAT_TO_FILL = table.minS
            ? table.minS
            : config.MIN_SEAT_TO_FILL;

          if (
            table.ms == 6 &&
            table.mode == "cash" &&
            table.ap == MIN_SEAT_TO_FILL &&
            uCount == 2
          ) {
            MIN_SEAT_TO_FILL = MIN_SEAT_TO_FILL + 1;
          }

          // if (
          //   table.ap >= MIN_SEAT_TO_FILL ||
          //   (rCount >= MAX_ROBOT_PER_TABLE && table.stdP.length == 0) ||
          //   table.ap == table.ms
          // ) {
          //   logger.info(
          //     "\nputRobotOnSeat------------" +
          //       table._id.toString() +
          //       "------------>>>>table.ap: ",
          //     table.ap
          //   );
          //   logger.info(
          //     "\nputRobotOnSeat--------------" +
          //       table._id.toString() +
          //       '---------->>>>Msg: "no need to put robots!!!"'
          //   );
          //   return false;
          // }
        }
        logger.info("chip---------------->", chip);

        let skip = commonClass.GetRandomInt(0, 1500);
        db.collection("game_users")
          .aggregate([
            {
              $match: {
                // _id: getInfo.MongoID("63a0436addc42b3c80e94a13"),
                "flags._ir": 1,
                s: "free",
              },
            },
            {
              $sample: {
                size: 1,
              },
            },
          ])
          // .find({ "flags._ir": 1, s: "free" })
          // .skip(skip)
          // .limit(1)
          .toArray(function (err, robots) {
            if (
              typeof robots != "undefined" &&
              robots != null &&
              robots.length > 0
            ) {
              let rbId = robots[0]._id.toString();

              let thp = 0;
              // let spc = 0;
              let hw = 0;
              let hl = 0;
              let hd = 0;
              let cw = 0;
              let cl = 0;
              let cdr = 0;
              let mcw = 0;

              let sdt = commonClass.subTime(108000); //30 days last login
              let wh = {
                _id: { $nin: uids },
                "flags._ir": 0,
                pp: { $nin: pps },
                "lasts.ll": { $lt: sdt },
                "lasts.llgt": { $lt: sdt },
                // ult: "FB",
                // det: { $ne: "html" },
              };
              let prj = {
                // un:1,
                // pp:1,
                "counters.thp": 1,
                // 'counters.spc':1,
                "counters.hw": 1,
                "counters.hl": 1,
                "counters.hd": 1,
                "counters.cw": 1,
                "counters.cl": 1,
                "counters.cdr": 1,
                "counters.mcw": 1,
              };

              let skip = commonClass.GetRandomInt(0, 10000); //for randomization

              db.collection("game_users")
                .find(wh)
                .skip(skip)
                .limit(1)
                .project(prj)
                .toArray(function (errr, uDetails) {
                  if (uDetails && uDetails.length > 0) {
                    thp = uDetails[0].counters.thp;
                    hw = uDetails[0].counters.hw;
                    hl = uDetails[0].counters.hl;
                    hd = uDetails[0].counters.hd;
                    cw = uDetails[0].counters.cw;
                    cl = uDetails[0].counters.cl;
                    cdr = uDetails[0].counters.cdr;
                    mcw = uDetails[0].counters.mcw;

                    let upData = {
                      $set: {
                        "counters.thp": thp,
                        "counters.hw": hw,
                        "counters.hl": hl,
                        "counters.hd": hd,
                        "counters.cw": cw,
                        "counters.cl": cl,
                        "counters.cdr": cdr,
                        "counters.mcw": mcw,
                      },
                      // $inc: {
                      //   Chips: chip,
                      //   totalcash: chip,
                      // },
                    };
                    logger.info(
                      "putRobotOnSeat------------>>>>upData: ",
                      upData
                    );
                    getInfo.UpdateUserData(rbId, upData, function () {
                      robotJoinTable(tbId, rbId);
                    });
                  } else {
                    db.collection("user_avatar")
                      .aggregate([
                        { $match: { use: true } },
                        { $sample: { size: 1 } },
                      ])
                      .toArray(function (err1, profile) {
                        robotJoinTable(tbId, rbId);
                        // let upData = {
                        //   $inc: {
                        //     Chips: chip,
                        //     totalcash: chip,
                        //   },
                        // };
                        // getInfo.UpdateUserData(rbId, upData, function () {
                        // robotJoinTable(tbId, rbId);
                        // });
                      });
                  }
                });
            } else {
              logger.info(
                'putRobotOnSeat------------>>>>>Error:"robots not found"'
              );

              generateRobot(function (rbId) {
                if (typeof rbId != "undefined" && rbId != null && rbId != "") {
                  robotJoinTable(tbId, rbId);
                } else {
                  logger.info(
                    'putRobotOnSeat-----2-------->>>>>>"robot not created"'
                  );
                }
              });
            }
          });
      }
    );
  } catch (error) {
    logger.error("-----> error putRobotOnSeat", error);
    getInfo.exceptionError(error);
  }
};
const robotJoinTable = (tbId, rbId) => {
  try {
    //rbId = robot id
    /* +-------------------------------------------------------------------+
    desc:function to join robot to seat
    i/p: tbId = table id , robotid = _id of robot
  +-------------------------------------------------------------------+ */
    logger.info("robotJoinTable------------->>>>>>");
    getInfo.GetTbInfo(
      tbId,
      { pi: 1, spcSi: 1, HumanCount: 1, uCount: 1 },
      function (table) {
        if (table) {
          var uScores = [];
          // var thp = -1;
          // var spc = -1;
          var nCount = 0; //newbie count
          var aCount = 0; // amateur count
          var pCount = 0; //pro count
          var gCount = 0; // god count

          for (var i in table.pi) {
            if (!_.isEmpty(table.pi[i]) && table.pi[i]._ir == 0) {
              uScores.push(table.pi[i].score);
              /*if(table.pi[i].isSpc && typeof table.pi[i].thp != 'undefined' && table.pi[i].thp != null){
            thp = table.pi[i].thp;
            // spc = table.pi[i].spc;
          }*/
            } else if (!_.isEmpty(table.pi[i]) && table.pi[i]._ir == 1) {
              if (table.pi[i].rType == "Newbie") {
                nCount++;
              } else if (table.pi[i].rType == "Amateur") {
                aCount++;
              } else if (table.pi[i].rType == "Pro") {
                pCount++;
              } else if (table.pi[i].rType == "God") {
                gCount++;
              }
            }
          }

          var tScore = 0;
          if (uScores.length > 1) {
            tScore = commonClass.getMedian(uScores);
          } else {
            tScore = uScores.length == 1 ? uScores[0] : 0;
          }

          logger.info(
            "[Bot Building]------" +
            tbId +
            "-------------------->>>>>>>>Table score: " +
            tScore
          );
          db.collection("robot_prob")
            .find({ from: { $lte: tScore } })
            .sort({ from: -1 })
            .toArray(function (err, robotType) {
              logger.info(
                "robotJoinTable---------robot set-------->>>>>>>: ",
                robotType[0]
              );
              var rType = "Newbie";
              if (robotType && robotType.length > 0) {
                var rInt = commonClass.GetRandomInt(0, 100);
                logger.info("robotJoinTable----------->>>>>>rInt: " + rInt);
                var bound = robotType[0].Newbie;
                if (rInt <= bound) {
                  rType = "Newbie";
                } else if (rInt <= (bound += robotType[0].Amateur)) {
                  rType = "Amateur";
                } else if (rInt <= (bound += robotType[0].Pro)) {
                  rType = "Pro";
                } else if (rInt <= (bound += robotType[0].God)) {
                  rType = "God";
                } else {
                  logger.info("God---!!!--->>>else");
                  rType = "God";
                }
              }
              logger.info(
                "robotJoinTable------main------>>>>>>rType: " + rType
              );
              logger.info(
                "[Bot Building]-------" +
                tbId +
                "----------->>>>>>>>Selected robot type: " +
                rType
              );

              logger.info(
                "robotJoinTable------final-------->>>>>>rType: " + rType
              );

              findTableAndJoinClass.joinSeat(tbId, "red", {
                _ir: 1,
                uid: rbId.toString(),
                rType: rType,
              });
              // });
            });
        } else {
          logger.info(
            'robotJoinTable-------------------->>>>>>>"table not found"'
          );
        }
      }
    );
  } catch (error) {
    logger.error("-----> error robotJoinTable", error);
    getInfo.exceptionError(error);
  }
};
const whichCardToThrow = (aCards, wildCard) => {
  try {
    //aCards = {pure :[[],....],seq:[[],....],set:[[],.....],dwd:[],cardSum};
    /* +-------------------------------------------------------------------+
    desc:function to find cards to be thrown by user
    i/p: aCards = {
        pure = 2D array of pure sequence
        seq = 2D array of impure sequence
        set = 2D array of set
        dwd = array of deadwood
        cardSum = cards points
      }
      wildCard = wildcard
    o/p: object = {
        pure = 2D array of pure sequence
        seq = 2D array of impure sequence
        set = 2D array of sets
        dwd = deadwood
        tCard = topcards
        cardSum = total cards points
      }
  +-------------------------------------------------------------------+ */

    var tCard = "";
    var deadwoods = cardCommonClass.getCardsWithoutJW(aCards.dwd, wildCard);
    if (deadwoods.length > 0) {
      tCard = deadwoods[0];
      aCards.dwd = _.without(aCards.dwd, tCard);
    }
    if (aCards.dwd.length > 0 && tCard == "") {
      //if there is any deadwood left then throw dead wood
      tCard = aCards.dwd.pop();
    }
    if (aCards.set.length > 0 && tCard == "") {
      for (var i in aCards.set) {
        if (aCards.set[i].length > 3) {
          tCard = aCards.set[i].pop();
          break;
        }
      }
    }
    if (aCards.seq.length > 0 && tCard == "") {
      for (var i in aCards.seq) {
        if (aCards.seq[i].length > 3) {
          tCard = aCards.seq[i].pop();
          break;
        }
      }
    }
    if (aCards.pure.length > 0 && tCard == "") {
      for (var i in aCards.pure) {
        if (aCards.pure[i].length > 3) {
          tCard = aCards.pure[i].pop();
          break;
        }
      }
    }

    logger.info("whichCardToThrow-----2--->>>>aCards: ", aCards);
    aCards.cardSum = cardCommonClass.cardsValidPoints(
      { pure: aCards.pure, seq: aCards.seq, set: aCards.set, dwd: aCards.dwd },
      wildCard
    ); //cards point should be 0 if robot declares

    var obj = {
      pure: aCards.pure,
      seq: aCards.seq,
      set: aCards.set,
      dwd: aCards.dwd,
      tCard: tCard,
      cardSum: aCards.cardSum,
    };
    logger.info("whichCardToThrow-------->>>>obj: ", obj);
    return obj;
  } catch (error) {
    logger.error("-----> error whichCardToThrow", error);
    getInfo.exceptionError(error);
  }
};

const robotPickCard = (tbId, logic, cb) => {
  try {
    /* +-------------------------------------------------------------------+
    desc:function to pick cards from table
    i/p: tbId = table id, logic = logic for playing, cb = callback function
  +-------------------------------------------------------------------+ */
    logger.info("robotPickCard------->>>>>logic: " + logic);
    const { START_TURN_TIMER } = GetConfig();
    getInfo.GetTbInfo(tbId, {}, function (table) {
      if (table) {
        logger.info(
          "[Bot Pick Cards]--------------" +
          table._id +
          "------------>>>>>logic: " +
          logic +
          " turn : " +
          table.turn
        );

        if (
          typeof table.pi[table.turn] == "undefined" ||
          typeof table.pi[table.turn].cards == "undefined"
        ) {
          logger.info("robot cards not found ");
          return false;
        }

        var robotCards = table.pi[table.turn].cards; //13 cards
        var rcards = table.pi[table.turn].cards;

        var robotPickCount = table.pi[table.turn].pickCount;
        var rSeq = table.rSeq;
        logger.info(
          "robotPickCard-------------" +
          table._id +
          "---------" +
          table.turn +
          "--------->>>>robotcards.length: (13): ",
          robotCards.length
        );

        // var analysedCards = cardCommonClass.cardsAnalyser(robotCards,table.wildCard);  //analysed the cards of robot
        var topCard = table.oDeck[table.oDeck.length - 1];

        if (!topCard || topCard == "") {
          logger.info(
            'robotPickCard:::::::::::Error:" invalid card ":::::' +
            table._id +
            "::::::::>>>>>>>>topCard: ",
            topCard,
            " date: " + new Date()
          );
          return false;
        }

        robotCards.push(topCard); //add the top odeck cards into robot cards
        var robotPfodCards = robotCards; //14 cards
        logger.info(
          "robotPickCard-------" +
          table._id +
          "----------" +
          table.turn +
          "---------->>>>robotPfodCards.length: (14): ",
          robotPfodCards.length
        );

        var declEnable = true; //flag for identifying if the LoserBot bot will declare or not, it will declare only if there are no users in table

        // var uCount = 0;
        // var players = getInfo.getPlayingUserInRound(table.pi, true);

        /*for(var i in players){
        if(players[i] && typeof players[i].si != 'undefined' && players[i]._ir == 0){
          uCount++;
        }
      }*/

        /*if(table.pi[table.turn].rType == 'Newbie' && uCount > 0){ //if there are users present on table then Newbie won't declare unless NEWBIE_BOT_DECL flag is set to true

        if(!config.NEWBIE_BOT_DECL){

          declEnable = false;
        }
      }*/

        /*if(table.spcSi != -1 && uCount > 0){
        declEnable = false;
      }*/

        logger.info(
          "robotPickCard------------------->>>>>>>>>> topCard:",
          topCard
        );
        logger.info(
          "robotPickCard------------------->>>>>>>>>> table.wildCard:",
          table.wildCard
        );

        var cond = false; //by default pick from close deck;
        var validate = false;
        if (typeof topCard != "undefined") {
          var DCScards = cardCommonClass.DifferCardSuit(topCard);
          var DCSwildCard = cardCommonClass.DifferCardSuit(table.wildCard);
          if (
            (DCScards.rank == DCSwildCard.rank || DCScards.suit == "j") &&
            table.trCount != 0
          ) {
            validate = true;
          }
          if (
            (DCScards.rank == DCSwildCard.rank || DCScards.suit == "j") &&
            table.trCount == 0
          ) {
            validate = true;
            cond = true;
          }
        }

        // var analysedPfodCards = cardCommonClass.cardsAnalyser(robotPfodCards,table.wildCard);
        var analysedPfodCards = godBotClass.GetSortedCard(
          robotPfodCards,
          table.wildCard
        );
        var vldt = true;
        if (analysedPfodCards.cardSum == 0) {
          var wctt1 = whichCardToThrow(analysedPfodCards, table.wildCard);
          robotPfodCards.splice(robotPfodCards.indexOf(wctt1.tCard), 1);
          analysedPfodCards1 = godBotClass.GetSortedCard(
            robotPfodCards,
            table.wildCard
          );
          if (analysedPfodCards1.cardSum == 0 && wctt1 != "") {
            vldt = true;
          } else {
            vldt = false;
          }
        } else {
          vldt = true;
        }

        logger.info(
          "[Robot cards after concating openDeck top cards]----(" +
          topCard +
          ")---" +
          table._id +
          "----------------->>>>>>cards:",
          analysedPfodCards
        );
        var jwArray = cardCommonClass.getJWcards(
          analysedPfodCards.dwd,
          table.wildCard
        );
        var botdecl = config.ROBOT_DCL;
        if (table.gt == "Pool") {
          botdecl = config.ROBOT_DCL_POOL;
        }
        if (
          declEnable &&
          !validate &&
          robotPickCount > botdecl &&
          vldt &&
          rSeq > config.ROBOT_DECL_TURN &&
          (analysedPfodCards.cardSum == 0 ||
            analysedPfodCards.dwd.length - jwArray.length <= 1) &&
          analysedPfodCards.pure.length > 0 &&
          analysedPfodCards.pure.length + analysedPfodCards.seq.length >= 2
        ) {
          //robot declare if it got sufficient sequences after PickCardFromOpenDeck
          //means robot gets the rummy if it takes cards form open deck
          pickCardClass.PickCardFromOpenDeck(
            {},
            { si: table.turn, tbid: table._id.toString() },
            function (resp) {
              //declare logic here
              logger.info(
                "robotPickCard---PickCardFromOpenDeck -before---11--resp.pi[resp.turn].cards: " +
                resp.pi[resp.turn].cards
              );
              var analysedCards = godBotClass.GetSortedCard(
                resp.pi[resp.turn].cards,
                resp.wildCard
              );
              var wctt = whichCardToThrow(analysedCards, resp.wildCard);
              logger.info(
                "robotPickCard---PickCardFromOpenDeck -before-----" +
                resp._id +
                "-----turn: " +
                resp.turn +
                "--wctt: " +
                wctt +
                '---->>>> "robot has completed hand after picking card from thrown cards"' +
                new Date()
              );
              let inter = commonClass.GetRandomInt(
                config.BOT_DECL_STRT,
                config.BOT_DECL_END
              );
              // setTimeout(function () {

              // }, inte * 1000);

              const jobId = `${resp.gt}:robotFinish:${resp._id.toString()}:${table.pi[table.turn].uid}`;
              scheduler.queues.robotFinish({
                timer: inter * 1000,
                jobId, robotFinish: true, table: resp, wctt
              });

              const jobData = {
                robotFinish: true, table: resp, wctt,
                calling: ROBOT_FINISH
              };
              const jobOption = { delay: inter * 1000, jobId };
              addQueue(jobData, jobOption);
            }
          );
        } else {
          if (validate == false) {
            if (logic == 3) {
              //logic 3 conditions here

              var combine = _.flatten(analysedPfodCards.pure)
                .concat(_.flatten(analysedPfodCards.seq))
                .concat(_.flatten(analysedPfodCards.set));

              // 1. check if the topcard is in pure, seq or set
              if (_.contains(combine, topCard)) {
                //if 1. true
                cond = true;
              } else {
                //if 1. false
                // 2. if topcard greater than 9  do not take it after certain thresold(5 pick turns)
                if (
                  robotPickCount <=
                  3 /* || parseInt(topCard.split('-')[1]) < 9*/
                ) {
                  // 3. if topcard makes a close seq and all versions of third card are not discarded
                  var dwdCards = analysedPfodCards.dwd;
                  var cSeqs = cardCommonClass.getCSeqs(
                    dwdCards,
                    table.wildCard
                  );
                  var foundCSeq = [];

                  if (_.contains(_.flatten(cSeqs), topCard)) {
                    //means topcard is in close seqs so check for all version of third card in discarded cards
                    //check for all version in oDeck

                    for (var k1 in cSeqs) {
                      if (_.contains(cSeqs[k1], topCard)) {
                        //check in which close sequence the top card is found
                        foundCSeq = cSeqs[k1];
                        break;
                      }
                    }

                    var allVersions1 = cardCommonClass.getCSeq3cd(
                      foundCSeq,
                      table.wildCard
                    ); //array of all verions of third card
                    allVersions1 = _.difference(allVersions1, table.oDeck);
                    if (allVersions1.length > 0) {
                      //if 2. true
                      //means not all versions of third card are discarded i.e not present in oDeck
                      if (
                        allVersions1.length >
                        _.difference(allVersions1, table.cDeck).length
                      ) {
                        //means some versions of third card are in close deck
                        cond = true;
                      }
                    }
                  }

                  if (!cond) {
                    //if 2. false

                    // 4. if topcard makes a close set and all versions of third card are not discarded
                    var cSets = cardCommonClass.getCSets(dwdCards);
                    var foundCSet = [];

                    if (_.contains(_.flatten(cSets), topCard)) {
                      //means topcard is in close sets so check for all version of third card in discarded cards
                      for (var k2 in cSets) {
                        if (_.contains(cSets[k2], topCard)) {
                          //check in which close set the top card is found
                          foundCSet = cSets[k2];
                          break;
                        }
                      }

                      var allVersions2 = cardCommonClass.getCSet3cd(
                        foundCSet,
                        table.wildCard
                      );
                      allVersions2 = _.difference(
                        allVersions2,
                        table.oDeck
                      ).length;
                      if (allVersions2.length > 0) {
                        //if 3. true
                        //means not all versions of third card are discarded i.e not present in oDeck
                        if (
                          allVersions2.length >
                          _.difference(allVersions2, table.cDeck).length
                        ) {
                          //means some versions of third card are in close deck
                          cond = true;
                        }
                      }
                    }
                  }
                }
              }

              /*for(var i in rcards){
                
              var diff = parseInt(topCard.split('-')[1])-parseInt(rcards[i].split('-')[1]);
              var wdiff = parseInt(topCard.split('-')[1])-parseInt(table.wildCard.split('-')[1]);
              var matchSuit = (topCard.split('-')[0] == rcards[i].split('-')[0]) ? true:false;
              var d = topCard.split('-');

              if(matchSuit && diff == 0 && wdiff != 0 && d[0] != 'j'){
                cond = false;
                logger.info("robotPickCard: top card of open deck same card in robot cards so not take");
              }
            }*/
            } else if (logic == 2) {
              //logic 2 conditions here

              var combineSeq = _.flatten(analysedPfodCards.pure).concat(
                _.flatten(analysedPfodCards.seq)
              );

              // 1. check if the topcard is in pure or seq
              // if( _.contains(_.flatten(combineSeq),topCard)){  //if 1. true
              if (_.contains(combineSeq, topCard)) {
                //if 1. true

                cond = true;
              } else {
                //if 1. false
                // 2. check if the topcard is in close seq and all the version of third are not in discarded cards
                var dwdCards = analysedPfodCards.dwd;
                // dwdCards = _.without(dwdCards,topCard);

                var cSeqs = cardCommonClass.getCSeqs(dwdCards, table.wildCard);
                var foundCSeq = [];

                if (_.contains(_.flatten(cSeqs), topCard)) {
                  //means topcard is in close seqs so check for all version of third card in discarded cards
                  //check for all version in oDeck

                  for (var k1 in cSeqs) {
                    if (_.contains(cSeqs[k1], topCard)) {
                      //check in which close sequence the top card is found
                      foundCSeq = cSeqs[k1];
                      break;
                    }
                  }

                  var allVersions1 = cardCommonClass.getCSeq3cd(
                    foundCSeq,
                    table.wildCard
                  ); //array of all verions of third card

                  if (_.difference(allVersions1, table.oDeck).length > 0) {
                    //if 2. true
                    //means not all versions of third card are discarded i.e not present in oDeck
                    cond = true;
                  }
                }

                if (!cond) {
                  //if 2. false

                  // 3. check if the topcard is in close set and all the version of third card are not in discarded cards
                  var cSets = cardCommonClass.getCSets(dwdCards);
                  var foundCSet = [];

                  if (_.contains(_.flatten(cSets), topCard)) {
                    //means topcard is in close sets so check for all version of third card in discarded cards
                    for (var k2 in cSets) {
                      if (_.contains(cSets[k2], topCard)) {
                        //check in which close set the top card is found
                        foundCSet = cSets[k2];
                        break;
                      }
                    }

                    var allVersions2 = cardCommonClass.getCSet3cd(
                      foundCSet,
                      table.wildCard
                    );

                    if (_.difference(allVersions2, table.oDeck).length > 0) {
                      //if 3. true
                      //means not all versions of third card are discarded i.e not present in oDeck
                      cond = true;
                    }
                  }
                }
              }
            } else {
              //logic 1 conditions here

              // 1. check if the top cards of open deck makes a sequence or not

              var rInt = commonClass.GetRandomInt(0, 100);
              if (rInt <= config.PICK_LOGIC1_PROB) {
                // randomize robot pick logic to make it easier  PICK_LOGIC1_PROB%

                var combineSeq = _.flatten(analysedPfodCards.pure).concat(
                  _.flatten(analysedPfodCards.seq)
                );
                // cond = _.contains(_.flatten(combineSeq),topCard);
                cond = _.contains(combineSeq, topCard);
              }
            }
          }

          if (cond) {
            //means pick cards forms a pure or seq
            pickCardClass.PickCardFromOpenDeck(
              {},
              { si: table.turn, tbid: table._id.toString() },
              async function (resp1) {
                var robotTime = commonClass.GetRandomInt(
                  config.ROBOT_THROW_DELAY[0],
                  config.ROBOT_THROW_DELAY[1]
                );
                var sum =
                  parseInt(config.ROBOT_TURN_DELAY[1]) +
                  parseInt(config.ROBOT_THROW_DELAY[1]);
                if (sum > START_TURN_TIMER) {
                  robotTime = 2;
                }
                // setTimeout(function () {
                //   logger.info('robotPickCard------pfod---->>>>>" throw"');
                //   if (typeof cb == "function") {
                //     cb(resp1._id.toString()); //throw logic here
                //   }
                // }, robotTime * 1000);
                const jobId = `${table.gt}:robotFinishDelay:${table._id.toString()}:${table.pi[table.turn].uid}`;
                // const queue = await scheduler.queues.robotFinish({
                //   timer: robotTime * 1000,
                //   jobId,
                // });
                const jobData = { calling: ROBOT_FINISH };
                const jobOption = { delay: robotTime * 1000, jobId };
                const queue = await addQueue(jobData, jobOption);
                const job = await queue.getJob(jobId);
                await job.finished();

                if (typeof cb == "function") {
                  cb(resp1._id.toString()); //throw logic here
                }
              }
            );
          } else {
            pickCardClass.PickCardFromCloseDeck(
              {},
              { si: table.turn, tbid: table._id.toString() },
              async function (table1) {
                //if no better choice then PickCardFromCloseDeck
                if (!table1) {
                  return false;
                }

                var robotPfcdCards = table1.pi[table1.turn].cards; //14 cards
                // logger.info('robotPickCard----------->>>>>robotPfcdCards: ',robotPfcdCards);
                logger.info(
                  "robotPickCard---------" +
                  table1._id +
                  "---------" +
                  table1.turn +
                  "---------->>>>>robotPfcdCards.length: (14): ",
                  robotPfcdCards.length
                );
                if (
                  (table.pi[table.turn].rType = "God" && config.NEW_GOD_LOGIC)
                ) {
                  var analysedPfcdCards = godBotClass.GetSortedCard(
                    robotPfcdCards,
                    table1.wildCard
                  );
                } else {
                  // var analysedPfcdCards = cardCommonClass.cardsAnalyser(robotPfcdCards,table1.wildCard);
                  var analysedPfcdCards = godBotClass.GetSortedCard(
                    robotPfcdCards,
                    table1.wildCard
                  );
                }
                logger.info(
                  "[Robot cards after concating closeDeck top cards]-------------" +
                  table1._id +
                  "--------->>>>>>cards:",
                  analysedPfcdCards
                );
                var vdt = true;
                if (analysedPfcdCards.cardSum == 0) {
                  var wctt1 = whichCardToThrow(
                    analysedPfcdCards,
                    table1.wildCard
                  );
                  robotPfcdCards.splice(robotPfcdCards.indexOf(wctt1.tCard), 1);
                  analysedPfcdCards1 = godBotClass.GetSortedCard(
                    robotPfcdCards,
                    table1.wildCard
                  );
                  if (analysedPfcdCards1.cardSum == 0 && wctt1 != "") {
                    vdt = true;
                  } else {
                    vdt = false;
                  }
                }

                var jwArray1 = cardCommonClass.getJWcards(
                  analysedPfcdCards.dwd,
                  table1.wildCard
                );
                var botdecl = config.ROBOT_DCL;
                if (table1.gt == "Pool") {
                  botdecl = config.ROBOT_DCL_POOL;
                }
                if (
                  declEnable &&
                  rSeq > config.ROBOT_DECL_TURN &&
                  robotPickCount > botdecl &&
                  vdt == true &&
                  (analysedPfcdCards.cardSum == 0 ||
                    analysedPfcdCards.dwd.length - jwArray1.length <=
                    1) /*analysedPfcdCards.dwd.length == 1*/ &&
                  analysedPfcdCards.pure.length > 0 &&
                  analysedPfcdCards.pure.length +
                  analysedPfcdCards.seq.length >=
                  2
                ) {
                  //robot declare if it got sufficient sequences if PickCardFromCloseDeck
                  logger.info(
                    "robotPickCard-------" +
                    table1._id +
                    "---------" +
                    table1.turn +
                    '---------->>>> "robot has completed hand after picking card from cDeck"'
                  );
                  //declare logic here
                  logger.info(
                    "robotPickCard-------------------table1.pi[table1.turn].cards:",
                    table1.pi[table1.turn].cards
                  );
                  let analysedCards = godBotClass.GetSortedCard(
                    table1.pi[table1.turn].cards,
                    table1.wildCard
                  );
                  let wctt = whichCardToThrow(analysedCards, table1.wildCard);
                  let inter = commonClass.GetRandomInt(
                    config.BOT_DECL_STRT,
                    config.BOT_DECL_END
                  );
                  logger.info(
                    "robotPickCard---PickCardFromCloseDeck-before-------" +
                    table1._id +
                    "-------" +
                    table1.turn +
                    "------wctt: " +
                    wctt +
                    "-------->>>>>" +
                    new Date()
                  );
                  // setTimeout(function () {
                  //   logger.info(
                  //     "robotPickCard---PickCardFromCloseDeck-after-------" +
                  //     table1._id +
                  //     "-------" +
                  //     table1.turn +
                  //     "------wctt: " +
                  //     wctt +
                  //     "-------->>>>>" +
                  //     new Date()
                  //   );

                  //   finishClass.Finish(
                  //     { card: wctt.tCard },
                  //     { tbid: table1._id.toString(), si: table1.turn },
                  //     function () {
                  //       var dCards = {
                  //         pure: wctt.pure,
                  //         seq: wctt.seq,
                  //         set: wctt.set,
                  //         dwd: wctt.dwd,
                  //       };
                  //       var ps = wctt.cardSum;
                  //       var int = commonClass.GetRandomInt(
                  //         config.BOT_DECL_STRT,
                  //         config.BOT_DECL_END
                  //       );
                  //       logger.info(
                  //         "robotPickCard---PickCardFromCloseDeck-after-------dCards: ",
                  //         dCards
                  //       );
                  //       logger.info(
                  //         'robotPickCard------pfod---->>>>>"after Finish int: "',
                  //         int
                  //       );
                  //       setTimeout(function () {
                  //         //robot will declare in 2 sec after finish

                  //         declareClass.Declare(
                  //           { dCards: dCards, ps: ps },
                  //           { si: table1.turn, tbid: table1._id.toString() }
                  //         ); //robot declare after PickCardFromCloseDeck
                  //       }, int * 1000);
                  //     }
                  //   );
                  // }, inte * 1000);

                  //robot declare after PickCardFromCloseDeck
                  const jobId = `${table1.gt}:robotFinish:${table1._id.toString()}:${table1.pi[table.turn].uid}`;
                  scheduler.queues.robotFinish({
                    timer: inter * 1000,
                    jobId, robotFinish: true, table: table1, wctt
                  });
                  const jobData = {
                    robotFinish: true, table: table1, wctt,
                    calling: ROBOT_FINISH
                  };
                  const jobOption = { delay: inter * 1000, jobId };
                  addQueue(jobData, jobOption);
                } else {
                  let robotTime = commonClass.GetRandomInt(
                    config.ROBOT_THROW_DELAY[0],
                    config.ROBOT_THROW_DELAY[1]
                  );
                  let sum = parseInt(config.ROBOT_TURN_DELAY[1]) + parseInt(config.ROBOT_THROW_DELAY[1]);
                  if (sum > START_TURN_TIMER) {
                    robotTime = 2;
                  }
                  // setTimeout(function () {
                  //   logger.info('robotPickCard------pfcd---->>>>>" throw"');
                  //   if (typeof cb == "function") {
                  //     cb(table1._id.toString()); //throw logic here
                  //   }
                  // }, robotTime * 1000);
                  const jobId = `${table1.gt}:robotFinishDelay:${table1._id.toString()}:${table1.pi[table1.turn].uid}`;
                  // const queue = await scheduler.queues.robotFinish({
                  //   timer: robotTime * 1000,
                  //   jobId,
                  // });
                  const jobData = { calling: ROBOT_FINISH };
                  const jobOption = { delay: robotTime * 1000, jobId };
                  const queue = await addQueue(jobData, jobOption);
                  const job = await queue.getJob(jobId);
                  await job.finished();
                  if (typeof cb == "function") {
                    cb(table1._id.toString()); //throw logic here
                  }
                }
              }
            );
          }
        }
      } else {
        logger.info(
          'robotPickCard:::::::::::::>>>>>>Error: "table not found!!!"'
        );
      }
    });
  } catch (error) {
    logger.error("-----> error robotPickCard", error);
    getInfo.exceptionError(error);
  }
};
const robotThrowCard = (tbId, logic) => {
  try {
    /* +-------------------------------------------------------------------+
    desc:function to handle robot cards throwing
    i/p: tbId = table id, logic = logic to appy for robot card throwing
  +-------------------------------------------------------------------+ */
    logger.info("robotThrowCard--------" + tbId + "------>>>>logic: " + logic);
    logger.info(
      "[Bot Discard Cards]---------" +
      tbId +
      "------------------------>>>>logic: " +
      logic
    );
    getInfo.GetTbInfo(tbId, {}, function (table) {
      //robot throw logic here
      if (
        table &&
        table.turn != -1 &&
        typeof table.pi[table.turn].cards != "undefined" &&
        table.tst == "RoundStarted"
      ) {
        logger.info(
          "robotThrowCard--------" + tbId + "-------->>>>turn: ",
          table.turn
        );
        var robotCards = table.pi[table.turn].cards; //14 cards
        var lpc = "";
        if (table.pi[table.turn].occ == 1) {
          lpc = table.pi[table.turn].lpc; // last picked card
        }
        logger.info("robotThrowCard------------->>>>lpc: ", lpc);

        if ((table.pi[table.turn].rType = "God" && config.NEW_GOD_LOGIC)) {
          var analysedRobotCards = godBotClass.GetSortedCard(
            robotCards,
            table.wildCard
          );
        } else {
          // var analysedRobotCards = cardCommonClass.cardsAnalyser(robotCards,table.wildCard);
          var analysedRobotCards = godBotClass.GetSortedCard(
            robotCards,
            table.wildCard
          );
        }

        logger.info(
          "[Bot Discard Cards]-------------" +
          tbId +
          "------------>>>>>>cards:",
          analysedRobotCards
        );
        var deadwood = analysedRobotCards.dwd; //deadwood cards
        var selectedCard = "";
        logger.info(
          "robotThrowCard-----------dwd----------->>>>deedwood: " + deadwood
        );
        if (deadwood.length == 0) {
          //if no deadwood found
          // var jwCards = cardCommonClass.getJWcards(robotCards,table.wildCard);
          // if(jwCards.length > 0 ){ //if there is joker or wildCards in robotcards then we throw random joker or wildCards
          // 	selectedCard = jwCards[commonClass.GetRandomInt(0,jwCards.length-1)];
          // 	logger.info('robotThrowCard-------joker-------->>>>>selectedCard: '+selectedCard);
          // }
          // else{  //means there is atleast one pure sequence and no seq, no joker or wildCards and others cards are  only sets

          var setsCards = _.flatten(analysedRobotCards.set);
          var setJW = cardCommonClass.getCardsWithoutJW(
            setsCards,
            table.wildCard
          );
          logger.info("robotThrowCard--------------setJW:", setJW);
          if (setJW.length > 0) {
            var sortedCards = cardCommonClass.sortCards(setJW, true).reverse();
            selectedCard = sortedCards[0];
            logger.info(
              "robotThrowCard-----------set----------->>>>selectedCard: " +
              selectedCard
            );
          } else {
            var seqsCards = _.flatten(analysedRobotCards.seq);
            var seqJW = cardCommonClass.getCardsWithoutJW(
              seqsCards,
              table.wildCard
            );
            logger.info("robotThrowCard--------------seqJW:", seqJW);
            if (seqJW.length > 0) {
              var sortedCards = cardCommonClass
                .sortCards(seqJW, true)
                .reverse();
              selectedCard = sortedCards[0];
              logger.info(
                "robotThrowCard-------seq----->>>selectedCard: " + selectedCard
              );
            } else {
              var pureCards = _.flatten(analysedRobotCards.pure);
              var pureJW = cardCommonClass.getCardsWithoutJW(
                pureCards,
                table.wildCard
              );
              logger.info("robotThrowCard--------------------pureJW: ", pureJW);
              var sortedCards = cardCommonClass
                .sortCards(pureJW, true)
                .reverse();
              selectedCard = sortedCards[0];
              logger.info(
                "robotThrowCard---------pure----------->>>>>selectedCard: " +
                selectedCard
              );
            }
          }
          // }
        } else {
          if (logic == 3) {
            //throw logic 3 here
            logger.info(
              "robotThrowCard-------------1------------->>>>>deadwood:",
              deadwood
            );
            var cSeqs = cardCommonClass.getCSeqs(deadwood, table.wildCard);

            if (lpc != "" && _.contains(deadwood, lpc) && deadwood.length > 1) {
              // return allVersions1[k2];
              var index = deadwood.indexOf(lpc);
              if (index > -1) {
                deadwood.splice(index, 1);
              }
            }

            for (var t in deadwood) {
              var DCScards = cardCommonClass.DifferCardSuit(lpc);
              var DCSwildCard = cardCommonClass.DifferCardSuit(deadwood[t]);
              if (
                DCScards.rank == DCSwildCard.rank &&
                DCScards.suit == DCSwildCard.suit &&
                deadwood.length > 1
              ) {
                var index1 = deadwood.indexOf(deadwood[t]);
                if (index1 > -1) {
                  deadwood.splice(index1, 1);
                }
              }
            }

            logger.info(
              "robotThrowCard-------------2------------->>>>>deadwood:",
              deadwood
            );
            var tempDwd = deadwood; //array to store main deadwood cards

            var newDwd1 = []; // array to store all deadwood cards after removing close sequence cards
            if (cSeqs.length > 0) {
              //means close sequence has been found
              //check all the third cards of all the close sequences whether their third cards are discarded or not
              for (var k1 in cSeqs) {
                var allVersions1 = cardCommonClass.getCSeq3cd(
                  cSeqs[k1],
                  table.wildCard
                );
                if (_.difference(allVersions1, table.oDeck).length == 0) {
                  //means all versions of the third card of this close sequence has been discarded
                  newDwd1.concat(cSeqs[k1]); //so complete close sequence will be push into discarded group
                }
              }
              logger.info(
                'robotThrowCard-----------logic3----------->>>>>"cSeqs found"'
              );
            }

            //now check for the close sets in discarded group
            if (newDwd1.length > 0) {
              //means some cards are in discared group then only check for close sets
              logger.info(
                'robotThrowCard-----------logic3----------->>>>"some cards are in discared group"'
              );
              var newDwd2 = []; //array to store cards after removing close sets cards
              var cSets = cardCommonClass.getCSets(newDwd1);

              if (cSets.length > 0) {
                //means close set has been found
                //check for all the versions of all the close sequences whether their cards are discarded or not
                for (var k2 in cSets) {
                  var allVersions2 = cardCommonClass.getCSet3cd(
                    cSets[k2],
                    table.wildCard
                  );
                  if (_.difference(allVersions2, table.oDeck).length == 0) {
                    //means all versions of the third card of this close set has been discarded
                    newDwd2.concat(cSets[k2]); //so complete close set will be push into discarded group
                  }
                }
                logger.info(
                  'robotThrowCard-----------logic3----------->>>>"cSets found"'
                );
              }

              if (newDwd2.length > 0) {
                //means still some cards are left in discarded group
                if (
                  lpc != "" &&
                  _.contains(newDwd2, lpc) &&
                  newDwd2.length > 1
                ) {
                  // return allVersions1[k2];
                  var index = newDwd2.indexOf(lpc);
                  if (index > -1) {
                    newDwd2.splice(index, 1);
                  }
                  logger.info("CDC 1 csacsvd: ", cards);
                }
                tempDwd = newDwd2;
                logger.info(
                  'robotThrowCard-----------logic3--------------->>>>"still some cards are left in discarded group"'
                );
              } else {
                //no remaining cards for that can make close sets
                if (
                  lpc != "" &&
                  _.contains(newDwd1, lpc) &&
                  newDwd1.length > 1
                ) {
                  // return allVersions1[k2];
                  var index = newDwd1.indexOf(lpc);
                  if (index > -1) {
                    newDwd1.splice(index, 1);
                  }
                  logger.info("CDC 1 csacsvd: ", cards);
                }
                tempDwd = newDwd1;
                logger.info(
                  'robotThrowCard-----------logic3--------------->>>>"no remaining cards for that can make close sets"'
                );
              }
            }

            logger.info("robotThrowCard----------------tempDwd: ", tempDwd);

            var finalDwd = []; //array to store final safe deadwood cards that cannot be used by next player
            //check for next player cards
            var nextTurn = getInfo.getNextPlayer(table);

            if (nextTurn) {
              nextTurn = nextTurn.nxt;
            }

            if (
              typeof nextTurn != "undefined" &&
              typeof table.pi[nextTurn] != "undefined" &&
              typeof table.pi[nextTurn].si != "undefined" &&
              typeof table.pi[nextTurn].cards != "undefined" &&
              table.pi[nextTurn].cards.length > 0
            ) {
              var nextCards = table.pi[nextTurn].cards;
              for (var x = 0; x < tempDwd.length; x++) {
                var card1 = [
                  tempDwd[x].split("-")[0],
                  parseInt(tempDwd[x].split("-")[1]),
                ];
                var check = true;
                for (var y = 0; y < nextCards.length; y++) {
                  var card2 = [
                    nextCards[y].split("-")[0],
                    parseInt(nextCards[y].split("-")[1]),
                  ];
                  var matchSuit = card1[0] == card2[0] ? true : false;
                  var diff = card1[1] - card2[1]; //difference between rank of two cards

                  if (
                    (matchSuit && diff <= 2 && diff >= -2) ||
                    (!matchSuit && diff == 0)
                  ) {
                    //first for seq and second for set
                    //means current card can be used in seq or set by next player so can't be add into discarded group
                    check = false;
                    logger.info(
                      'robotThrowCard-----------logic3------111------->>>>>"user can use card": ',
                      tempDwd[x]
                    );
                    break;
                  } else if (
                    matchSuit &&
                    ((card1[1] == 12 && card2[1] == 1) ||
                      (card1[1] == 1 && card2[1] == 12))
                  ) {
                    //sspecial case: ace,queen
                    //means current card can be used in seq or set by next player so can't be add into discarded group
                    check = false;
                    logger.info(
                      'robotThrowCard-----------logic3-----222-------->>>>>"user can use card": ',
                      tempDwd[x]
                    );
                    break;
                  } else if (
                    matchSuit &&
                    ((card1[1] == 13 && card2[1] == 1) ||
                      (card1[1] == 1 && card2[1] == 13))
                  ) {
                    //special case: ace,king
                    //means current card can be used in seq or set by next player so can't be add into discarded group
                    check = false;
                    logger.info(
                      'robotThrowCard-----------logic3------333------->>>>>"user can use card": ',
                      tempDwd[x]
                    );
                    break;
                  }
                }
                if (check) {
                  logger.info(
                    'robotThrowCard-----------logic3------------->>>>>"cards not to be used by next player": ',
                    tempDwd[x]
                  );
                  finalDwd.push(tempDwd[x]);
                }
              }
              logger.info(
                'robotThrowCard-----------logic3------------->>>>>"next turn user found"'
              );
            }

            var cwJW = []; //array to store cards without jokers/wildcards
            if (finalDwd.length > 0) {
              logger.info(
                'robotThrowCard-----------logic3------------->>>>>"we got final cards"'
              );
              cwJW = cardCommonClass.getCardsWithoutJW(
                finalDwd,
                table.wildCard
              );
            } else {
              logger.info(
                'robotThrowCard-----------logic3------------->>>>>"finaldwd cards not found"'
              );
              cwJW = cardCommonClass.getCardsWithoutJW(tempDwd, table.wildCard);
            }

            if (cwJW.length > 0) {
              //if there are some cards other than joker/wildCard then take the highest card i.e sortCards[0]
              var sortedCards = cardCommonClass.sortCards(cwJW, true).reverse();
              selectedCard = sortedCards[0];
              logger.info(
                "robotThrowCard-----logic3------if----->>>>>selectedCard: " +
                selectedCard
              );
            } else {
              //if all the deadwood cards are joker/ wildCards then take the first card
              if (finalDwd.length > 0) {
                selectedCard = finalDwd[0];
                logger.info(
                  "robotThrowCard-----logic3------else--if---->>>>>selectedCard: " +
                  selectedCard
                );
              } else {
                selectedCard = tempDwd[0];
                logger.info(
                  "robotThrowCard-----logic3------else--else---->>>>>selectedCard: " +
                  selectedCard
                );
              }
            }
          } else if (logic == 2) {
            //throw logic 3 here

            // dwdCards = _.without(dwdCards,topCard);
            logger.info("robotThrowCard------------------->>>>>>logic2");

            if (lpc != "" && _.contains(deadwood, lpc) && deadwood.length > 1) {
              // return allVersions1[k2];
              var index = deadwood.indexOf(lpc);
              if (index > -1) {
                deadwood.splice(index, 1);
              }
            }

            for (var t in deadwood) {
              var DCScards = cardCommonClass.DifferCardSuit(lpc);
              var DCSwildCard = cardCommonClass.DifferCardSuit(deadwood[t]);
              if (
                DCScards.rank == DCSwildCard.rank &&
                DCScards.suit == DCSwildCard.suit &&
                deadwood.length > 1
              ) {
                var index1 = deadwood.indexOf(deadwood[t]);
                if (index1 > -1) {
                  deadwood.splice(index1, 1);
                }
              }
            }

            var cSeqs = cardCommonClass.getCSeqs(deadwood, table.wildCard);

            var finalDwd = deadwood;

            var newDwd1 = [];
            if (cSeqs.length > 0) {
              //means close sequence has been found
              //check all the third cards of all the close sequences whether their third cards are discarded or not
              for (var k1 in cSeqs) {
                var allVersions1 = cardCommonClass.getCSeq3cd(
                  cSeqs[k1],
                  table.wildCard
                );
                if (_.difference(allVersions1, table.oDeck).length == 0) {
                  //means all versions of the third card of this close sequence has been discarded
                  newDwd1.concat(cSeqs[k1]); //so complete sequence will be push into discarded group
                }
              }
              logger.info(
                'robotThrowCard-----------logic3----------->>>>>"cSeqs found"'
              );
            }

            //now check for the close sets in discarded group
            if (newDwd1.length > 0) {
              //means some cards are in discared group then only check for close sets
              logger.info(
                'robotThrowCard-----------logic2----------->>>>"some cards are in discared group"'
              );
              var newDwd2 = [];
              var cSets = cardCommonClass.getCSets(newDwd1);

              if (cSets.length > 0) {
                //means close set has been found
                //check for all the versions of all the close sequences whether their cards are discarded or not
                for (var k2 in cSets) {
                  var allVersions2 = cardCommonClass.getCSet3cd(
                    cSets[k2],
                    table.wildCard
                  );
                  if (_.difference(allVersions2, table.oDeck).length == 0) {
                    //means all versions of the third card of this close set has been discarded
                    newDwd2.concat(cSets[k2]);
                  }
                }
                logger.info(
                  'robotThrowCard-----------logic2----------->>>>>"cSeqs found"'
                );
              }

              if (newDwd2.length > 0) {
                //means still some cards are left in discarded group

                finalDwd = newDwd2;
                logger.info(
                  'robotThrowCard-----------logic2----------->>>>>"still some cards are left in discarded group"'
                );
              } else {
                //no remaining cards for that can make close sets
                finalDwd = newDwd1;
                logger.info(
                  'robotThrowCard-----------logic2----------->>>>>"no remaining cards for that can make close sets"'
                );
              }
            }

            var cwJW = cardCommonClass.getCardsWithoutJW(
              finalDwd,
              table.wildCard
            );

            if (cwJW.length > 0) {
              //if there are some cards other than joker/wildCard then take the highest card i.e sortCards[0]
              var sortedCards = cardCommonClass.sortCards(cwJW, true).reverse();
              selectedCard = sortedCards[0];
              logger.info(
                "robotThrowCard-----logic2----if--->>>>>selectedCard: " +
                selectedCard
              );
            } else {
              //if all the deadwood cards are joker/ wildCards then take the first card
              // selectedCard = finalDwd[0];
              // logger.info('robotThrowCard------logic2---else--->>>>>selectedCard: '+selectedCard)
              var cwJW1 = cardCommonClass.getCardsWithoutJW(
                deadwood,
                table.wildCard
              );

              if (cwJW1.length > 0) {
                //if there are some cards other than joker/wildCard then take the highest card i.e sortCards[0]
                var sortedCards = cardCommonClass
                  .sortCards(cwJW1, true)
                  .reverse();
                selectedCard = sortedCards[0];
                logger.info(
                  "robotThrowCard------logic1---if--->>>>>selectedCard: " +
                  selectedCard
                );
              } else {
                selectedCard = deadwood[0];
                logger.info(
                  "robotThrowCard------logic1--else---->>>>>selectedCard: " +
                  selectedCard
                );
              }
            }
          } else {
            //throw logic 1 here

            var cwJW = cardCommonClass.getCardsWithoutJW(
              deadwood,
              table.wildCard
            );

            if (cwJW.length > 0) {
              //if there are some cards other than joker/wildCard then take the highest card i.e sortCards[0]
              var sortedCards = cardCommonClass.sortCards(cwJW, true).reverse();
              selectedCard = sortedCards[0];
              logger.info(
                "robotThrowCard------logic1---if--->>>>>selectedCard: " +
                selectedCard
              );
            } else {
              //if all the deadwood cards are joker/ wildCards then take the first card
              selectedCard = deadwood[0];
              logger.info(
                "robotThrowCard------logic1--else---->>>>>selectedCard: " +
                selectedCard
              );
            }
          }
        }
        if (parseInt(selectedCard.split("-")[1]) == 14) {
          //made ace rank as 1 if 14
          selectedCard =
            selectedCard.split("-")[0] + "-1-" + selectedCard.split("-")[2];
        }

        throwCardClass.ThrowCard(
          { card: selectedCard, bet: table.pi[table.turn].bet },
          { si: table.turn, tbid: table._id.toString() }
        );
      } else {
        logger.info('robotThrowCard---------->>>>>>>: Error:"table not found"');
      }
    });
  } catch (error) {
    logger.error("-----> error robotThrowCard", error);
    getInfo.exceptionError(error);
  }
};
const robotDrop = (tbId, cb) => {
  try {
    /* +-------------------------------------------------------------------+
    desc:function to handle robot cards dropping
    i/p: tbId = table id, cb = callback function
  +-------------------------------------------------------------------+ */
    getInfo.GetTbInfo(tbId, {}, function (table) {
      if (table && table.pi && table.pi[table.turn]) {
        if (table.gt == "Deal") {
          if (typeof cb == "function") {
            cb(false);
          }
          return;
        }

        var players = getInfo.getPlayingUserInRound(table.pi);
        var rCount = 0;
        var uCount = 0;

        for (x in players) {
          if (players[x]._ir == 0) {
            uCount++;
          } else {
            rCount++;
          }
        }
        logger.info(
          "robotDrop---------" +
          tbId +
          "------------>>>>uCount: " +
          uCount +
          " rCount: " +
          rCount
        );
        if (uCount < 3) {
          if (typeof cb == "function") {
            cb(false);
          }
          return;
        }

        if (table.pi[table.turn].pickCount == 0) {
          var dropType = "first";
        } else {
          var dropType = "middle";
        }

        var rType = table.pi[table.turn].rType;
        logger.info(
          "robotdrop--------------->>>>dropType: ",
          dropType,
          " rType: ",
          rType
        );

        var rInt1 = commonClass.GetRandomInt(0, 100);
        // var bound = res.dropType.table.pi[table.turn].rType.logic1;
        //logger.info("------======",RDROP);
        if (!rType || rType == "") {
          logger.info(
            "robotdrop:::::::::::::::>>>>>>>Error:::::::::>>>>rType: " +
            rType +
            "---" +
            new Date()
          );
          return false;
        }
        eval("var bound = RDROP." + dropType + "." + rType + ".logic1");
        // var bound = 50;
        var logic = 1;
        var logicN = "logic1";
        if (rInt1 <= bound) {
          logic = 1;
          logicN = "logic1";
        } else {
          logic = 2;
          logicN = "logic2";
        }
        logger.info(
          "[Bot Drop]---------" +
          tbId +
          "--------->>>>>>dropType: " +
          dropType +
          "  logicN: " +
          logicN
        );

        if (rType == "God" && config.NEW_GOD_LOGIC) {
          var all_seq = godBotClass.GetSortedCard(
            table.pi[table.turn].cards,
            table.wildCard
          );
        } else {
          // var all_seq = cardCommonClass.cardsAnalyser(table.pi[table.turn].cards, table.wildCard);
          var all_seq = godBotClass.GetSortedCard(
            table.pi[table.turn].cards,
            table.wildCard
          );
        }
        // var point = 20;
        eval("var point = RDROP." + dropType + "." + logicN + ".base");
        eval(
          "point += (all_seq.pure.length > 0)? RDROP." +
          dropType +
          "." +
          logicN +
          ".pures*all_seq.pure.length : 0"
        );
        eval(
          "point += (all_seq.seq.length > 0)? RDROP." +
          dropType +
          "." +
          logicN +
          ".seqs*all_seq.seq.length : 0"
        );
        eval(
          "point += (all_seq.set.length > 0)? RDROP." +
          dropType +
          "." +
          logicN +
          ".sets*all_seq.set.length : 0"
        );

        logger.info(
          "[Bot Drop]-----------" +
          tbId +
          "----------->>>>>>(pures: " +
          all_seq.pure.length +
          ", seq: " +
          all_seq.seq.length +
          ", set: " +
          all_seq.set.length +
          ")"
        );

        if (logic == 2) {
          var deadwood = all_seq.dwd;
          var cSeq = cardCommonClass.getCSeqs(deadwood, table.wildCard);
          deadwood = _.difference(deadwood, _.flatten(cSeq));
          var cSet = cardCommonClass.getCSeqs(deadwood, table.wildCard);
          deadwood = _.difference(deadwood, _.flatten(cSet));
          var joker = cardCommonClass.getJWcards(deadwood, table.wildCard);

          eval(
            "point += (cSeq.length > 0)? RDROP." +
            dropType +
            "." +
            logicN +
            ".cSeqs*cSeq.length : 0"
          );
          eval(
            "point += (cSet.length > 0)? RDROP." +
            dropType +
            "." +
            logicN +
            ".cSets*cSet.length : 0"
          );
          eval(
            "point += (joker.length > 0)? RDROP." +
            dropType +
            "." +
            logicN +
            ".jw*joker.length : 0"
          );
          logger.info(
            "[Bot Drop]-----------" +
            tbId +
            "---------->>>>>>(c.Seqs:" +
            cSeq.length +
            ", c.Sets: " +
            cSet.length +
            ", jokers/wildCards: " +
            joker.length +
            ")"
          );
          if (dropType == "middle") {
            eval(
              "point += (all_seq.cardSum > 0)? RDROP." +
              dropType +
              "." +
              logicN +
              ".pts*(config.MAX_DEADWOOD_PTS-all_seq.cardSum) : 0"
            );
          }

          logger.info("robotdrop-------------->>>>>>>>>point", point);
        }

        var rInt2 = commonClass.GetRandomInt(0, 100);
        logger.info("robotdrop-------------->>>>>>>>>rInt2", rInt2);

        if (rInt2 <= point) {
          logger.info("robotdrop-------------->>>>>>>>>false");
          logger.info(
            "[Bot Drop]-----------" +
            tbId +
            '--------->>>>>>>>>"bot will not drop"'
          );
          if (typeof cb == "function") {
            cb(false);
          }
        } else {
          logger.info("robotdrop-------------->>>>>>>>>true");
          logger.info(
            "[Bot Drop]-------------" +
            tbId +
            '---------->>>>>>>>>"bot will drop"'
          );
          if (typeof cb == "function") {
            cb(true);
          }
        }
      } else {
        logger.info(
          'robotDrop---------------->>>>>"table not found or bot data not found"'
        );
      }
    });
  } catch (error) {
    logger.error("-----> error robotDrop", error);
    getInfo.exceptionError(error);
  }
};

const robotActions = (tbId) => {
  try {
    /* +-------------------------------------------------------------------+
    desc:function to handle robot action cases
    i/p: tbId = table id
  +-------------------------------------------------------------------+ */
    getInfo.GetTbInfo(tbId, {}, function (table) {
      if (table && table.pi && table.pi[table.turn]) {
        logger.info(
          "robotActions-------------------->>>>>>>table.turn : " +
          table.turn +
          " table.pi[table.turn]: ",
          table.pi[table.turn],
          " table.pi[table.turn].rType: " + table.pi[table.turn].rType
        );
        var rType = table.pi[table.turn].rType;
        if (typeof rType == "undefined" || rType == null || rType == "") {
          logger.info(
            "robotActions:::::" +
            tbId +
            "::::::Error:::::::>>>>>>>>rType : " +
            rType +
            "---------" +
            new Date()
          );
          return false;
        }
        eval("var pLogicProb = RPLAY.PICK." + rType); //get the robot pick probability based on level
        logger.info("robotActions-------->>>pLogicProb: ", pLogicProb);

        var bound = pLogicProb.logic1;
        var r = commonClass.GetRandomInt(0, 100);
        var logic = 1;
        if (r <= bound) {
          logic = 1;
        } else if (r <= (bound += pLogicProb.logic2)) {
          logic = 2;
        } else if (r <= (bound += pLogicProb.logic3)) {
          logic = 3;
        } else {
          logic = 1;
        }
        logger.info("robotActions----1---->>>>>>logic: ", logic);

        logic = 3;
        robotPickCard(table._id.toString(), logic, function (tbId1) {
          //discard probability logic starts here
          eval("var dLogicProb = RPLAY.DISCARD." + rType);
          logger.info("robotActions--------->>>>>>dLogicProb: ", dLogicProb);

          var bound1 = dLogicProb.logic1;
          r = commonClass.GetRandomInt(0, 100);
          logic = 1;
          if (r <= bound1) {
            logic = 1;
          } else if (r <= (bound1 += dLogicProb.logic2)) {
            logic = 2;
          } else if (r <= (bound1 += dLogicProb.logic3)) {
            logic = 3;
          } else {
            logic = 1;
          }
          logger.info("robotActions----2---->>>>>>logic: ", logic);

          logic = 2;
          robotThrowCard(tbId1, logic);
        });
      } else {
        logger.info(
          'robotActions--------------------->>>>>>Error: "table not found"'
        );
      }
    });
  } catch (error) {
    logger.error("-----> error robotActions", error);
    getInfo.exceptionError(error);
  }
};
const robotTurnStarted = (tbId) => {
  try {
    /* +-------------------------------------------------------------------+
    desc:function to handle robot turn
    i/p: tbId = table id
  +-------------------------------------------------------------------+ */
    getInfo.GetTbInfo(tbId, { pi: 1, turn: 1 }, function (table) {
      logger.info("robotTurnStarted------>>>table: ", table);
      if (!table) {
        logger.info(
          'robotTurnStarted------------>>>>>>Error: "table not found!!!"'
        );
        return false;
      }

      // card pick probability  logic here

      //drop logic here
      robotDrop(tbId, function (isDrop) {
        if (isDrop) {
          logger.info("robotTurnStarted---------drop the robot--------");
          dropCardClass.DropCards(
            { internalDropCards: true },
            { tbid: tbId.toString(), si: table.turn }
          );
        } else {
          logger.info("robotTurnStarted---------do not drop the robot--------");

          robotActions(tbId);
        }
      });
    });
  } catch (error) {
    logger.error("-----> error robotTurnStarted", error);
    getInfo.exceptionError(error);
  }
};
const lateRobotDeclare = (table, si) => {
  try {
    //if user live player first declare then this function is called
    /* +-------------------------------------------------------------------+
    desc:function to handle late robot declaration
    i/p: table = table details , si = seat index of user
  +-------------------------------------------------------------------+ */
    let analysedCards, analysedCards1;
    if (!table) {
      logger.info(
        'lateRobotDeclare:::::::::::>>>>>Error: "table not found!!!"'
      );
      return false;
    }
    if (table.pi[si].rType == "God" && config.NEW_GOD_LOGIC) {
      analysedCards = godBotClass.GetSortedCard(
        table.pi[si].cards,
        table.wildCard
      );
    } else {
      analysedCards1 = cardCommonClass.cardsAnalyser(
        table.pi[si].cards,
        table.wildCard
      );
      analysedCards = godBotClass.GetSortedCard(
        table.pi[si].cards,
        table.wildCard
      );
      if (analysedCards1.cardsSum < analysedCards.cardsSum) {
        analysedCards = analysedCards1;
      }
    }
    logger.info("lateRobotDeclare------>>>>analysedCards: ", analysedCards);
    let ps = 0;
    let dCards = {};
    if (
      analysedCards.pure.length > 0 &&
      analysedCards.pure.length + analysedCards.seq.length > 1
    ) {
      //means the grouping is valid

      dCards = {
        pure: analysedCards.pure,
        seq: analysedCards.seq,
        set: analysedCards.set,
        dwd: analysedCards.dwd,
      };
      ps = analysedCards.cardSum;
    } else if (
      analysedCards.pure.length > 0 &&
      analysedCards.pure.length + analysedCards.seq.length == 1
    ) {
      let temp = analysedCards.seq
        .concat(analysedCards.set)
        .concat(analysedCards.dwd);
      temp = _.flatten(temp);
      dCards = { pure: analysedCards.pure, seq: [], set: [], dwd: temp };
      if (table.gt == "Pool" && table.pt == 61) {
        ps = cardCommonClass.poolCardsSum(temp, table.wildCard);
      } else {
        ps = cardCommonClass.cardsSum(temp, table.wildCard);
      }
      // ps = cardCommonClass.cardsSum(temp, table.wildCard);
    } else {
      //means all the cards will be considered as deadwood
      let temp = analysedCards.pure
        .concat(analysedCards.seq)
        .concat(analysedCards.set)
        .concat(analysedCards.dwd);
      temp = _.flatten(temp);
      dCards = { pure: [], seq: [], set: [], dwd: temp };
      if (table.gt == "Pool" && table.pt == 61) {
        ps = cardCommonClass.poolCardsSum(temp, table.wildCard);
      } else {
        ps = cardCommonClass.cardsSum(temp, table.wildCard);
      }
      // ps = cardCommonClass.cardsSum(temp, table.wildCard);
    }

    let r = commonClass.GetRandomInt(
      config.ROBOT_DECL_STIME,
      config.ROBOT_DECL_ETIME
    );
    // setTimeout(function () {
    //   //delay for robot declaration after someone has finished
    //   declareClass.Declare(
    //     { dCards: dCards, ps: ps },
    //     { si: si, tbid: table._id.toString() }
    //   );
    // }, r * 1000);
    const jobId = `${table.gt}:delayDeclare:${table._id.toString()}:${table.pi[si].uid}`;
    // scheduler.queues.delayDeclare({
    //   timer: r * 1000,
    //   jobId,
    //   firstParams: { dCards: dCards, ps: ps },
    //   secondParams: { si: si, tbid: table._id.toString() }
    // });
    const jobData = {
      firstParams: { dCards: dCards, ps: ps },
      secondParams: { si: si, tbid: table._id.toString() },
      calling: DELAY_DECLARE
    };
    const jobOption = { delay: r * 1000, jobId };
    addQueue(jobData, jobOption);
  } catch (error) {
    logger.error("-----> error lateRobotDeclare", error);
    getInfo.exceptionError(error);
  }
};

const lateRobotDeclarePool = (table, si, r) => {
  try {
    //if user live player first declare then this function is called
    /* +-------------------------------------------------------------------+
    desc:function to handle late robot declaration
    i/p: table = table details , si = seat index of user
  +-------------------------------------------------------------------+ */
    logger.info("--r----->", r);
    let analysedCards, analysedCards1;
    if (!table) {
      logger.info(
        'lateRobotDeclare:::::::::::>>>>>Error: "table not found!!!"'
      );
      return false;
    }
    logger.info("table.pi[si].rType------>", table.pi[si].rType, si);
    if (table.pi[si].rType == "God" && config.NEW_GOD_LOGIC) {
      analysedCards = godBotClass.GetSortedCard(
        table.pi[si].cards,
        table.wildCard
      );
    } else {
      analysedCards1 = cardCommonClass.cardsAnalyser(
        table.pi[si].cards,
        table.wildCard
      );
      logger.info("analysedCards1------->", analysedCards1);
      analysedCards = godBotClass.GetSortedCard(
        table.pi[si].cards,
        table.wildCard
      );
      logger.info("analysedCards------>", analysedCards);
      if (analysedCards1.cardsSum < analysedCards.cardsSum) {
        analysedCards = analysedCards1;
      }
    }
    logger.info("lateRobotDeclare------>>>>analysedCards: ", analysedCards);
    let ps = 0;
    let dCards = {};
    if (
      analysedCards.pure.length > 0 &&
      analysedCards.pure.length + analysedCards.seq.length > 1
    ) {
      //means the grouping is valid

      dCards = {
        pure: analysedCards.pure,
        seq: analysedCards.seq,
        set: analysedCards.set,
        dwd: analysedCards.dwd,
      };
      ps = analysedCards.cardSum;
    } else if (
      analysedCards.pure.length > 0 &&
      analysedCards.pure.length + analysedCards.seq.length == 1
    ) {
      let temp = analysedCards.seq
        .concat(analysedCards.set)
        .concat(analysedCards.dwd);
      temp = _.flatten(temp);
      dCards = { pure: analysedCards.pure, seq: [], set: [], dwd: temp };
      if (table.gt == "Pool" && table.pt == 61) {
        ps = cardCommonClass.poolCardsSum(temp, table.wildCard);
      } else {
        ps = cardCommonClass.cardsSum(temp, table.wildCard);
      }
      // ps = cardCommonClass.cardsSum(temp, table.wildCard);
    } else {
      //means all the cards will be considered as deadwood
      let temp = analysedCards.pure
        .concat(analysedCards.seq)
        .concat(analysedCards.set)
        .concat(analysedCards.dwd);
      temp = _.flatten(temp);
      dCards = { pure: [], seq: [], set: [], dwd: temp };
      if (table.gt == "Pool" && table.pt == 61) {
        ps = cardCommonClass.poolCardsSum(temp, table.wildCard);
      } else {
        ps = cardCommonClass.cardsSum(temp, table.wildCard);
      }
      // ps = cardCommonClass.cardsSum(temp, table.wildCard);
    }
    logger.info("r------->", r, si);
    logger.info("ps---->", ps);
    // setTimeout(function () {
    //   //delay for robot declaration after someone has finished
    //   declareClass.Declare(
    //     { dCards: dCards, ps: ps },
    //     { si: si, tbid: table._id.toString() }
    //   );
    // }, r * 1000);
    const jobId = `${table.gt}:delayDeclare:${table._id.toString()}:${table.pi[si].uid}`;
    // scheduler.queues.delayDeclare({
    //   timer: r * 1000,
    //   jobId,
    //   firstParams: { dCards: dCards, ps: ps },
    //   secondParams: { si: si, tbid: table._id.toString() }
    // });
    const jobData = {
      firstParams: { dCards: dCards, ps: ps },
      secondParams: { si: si, tbid: table._id.toString() },
      calling: DELAY_DECLARE
    };
    const jobOption = { delay: r * 1000, jobId };
    addQueue(jobData, jobOption);
  } catch (error) {
    logger.error("-----> error lateRobotDeclare", error);
    getInfo.exceptionError(error);
  }
};

const robotLeave = (tbId, si) => {
  try {
    //removes single robot
    /* +-------------------------------------------------------------------+
    desc:function to handle robot leaving
    i/p: tbId = table id ,si = seat index
  +-------------------------------------------------------------------+ */
    getInfo.GetTbInfo(tbId, {}, function (table) {
      if (!table) {
        logger.info('robotLeave:::::::::>>>>>Error: "table not found!!!"');
        return false;
      }
      logger.info('--table.pi[si].upc-------->', table.pi[si].upc);
      getInfo.UpdateUserData(
        table.pi[si].uid,
        {
          $set: { tbid: "", s: "free", sck: "" },
          $inc: { totalcash: table.pi[si].upc }
        },
        function () { }
      );
      db.collection("playing_table").findAndModify(
        { _id: table._id, "pi.si": si },
        {},
        {
          $set: { la: new Date(), ctrlServer: SERVER_ID, "pi.$": {} },
          $inc: { ap: -1 },
        },
        { new: true },
        async function (err, resp) {
          if (resp && resp.value) {
          
            if (resp.value.ap == 0) {
              logger.info(
                "robotLeave------------------>>>>>>>>table deleted: ",
                resp.value
              );
              db.collection("play_track").updateOne(
                { tbid: resp.value._id.toString() },
                { $set: { tet: new Date() } },
                function () { }
              );

              db.collection("last_deal").deleteOne(
                { tbid: resp.value._id.toString() },
                function () { }
              );

              db.collection("playing_table").deleteOne(
                { _id: resp.value._id },
                function () { }
              );
              db.collection("user_cash_percent").deleteOne(
                { tableId: resp.value._id },
                function () { }
              );

              // setTimeout(() => {
              //   db.collection("tableHistory").deleteMany({ tableId: getInfo.MongoID(resp.value._id) });
              // }, 3000);

              // notiClass.deleteTableNoti(resp.value._id.toString());
              //remove all table invitation for this table
            }
          }
        }
      );
    });
  } catch (error) {
    logger.error("-----> error robotLeave", error);
    getInfo.exceptionError(error);
  }
};
const removeRobots = (tbId) => {
  try {
    //removes multiple robot
    /* +-------------------------------------------------------------------+
    desc:function to handle multiple robot leaving
    i/p: tbId = table id 
  +-------------------------------------------------------------------+ */
    // getInfo. GetTbInfo(tbId,{},function(table){
    const { MAX_DEADWOOD_PTS, TAX_VALUE, TAX } = GetConfig();
    getInfo.UpdateTableData(
      tbId,
      {
        $set: {
          _isLeave: 0,
          /*tst:'',pv:0,*/ wildCard: "",
          oDeck: [],
          declCount: 0,
          playCount: 0,
          cDeck: [],
          turn: -1,
          fnsPlayer: -1,
          hist: [],
          ctt: new Date(),
        },
      },
      async function (table) {
        logger.info("--table-----table---", table);
        if (!table) {
          logger.info('removeRobots::::::::::>>>>Error: "table not found!!!"');
          return false;
        }

        jobTimerClass.cancelJobOnServers(tbId, table.jid);
        let players = getInfo.getPlayingUserInRound(table.pi);
        logger.info("removeRobots----1-" + table._id + "---->>>> ");
        for (let x in players) {
          if (players[x]._ir == 1) {
            if (table.mode == "cash") {
              if (table.gt == "Points" && table.tst == "RoundStarted") {
                logger.info('---in if-------->', x, players.length - 1);
                if (x < players.length - 1) {
                  let pvv = table.bv * MAX_DEADWOOD_PTS;
                  let fChips = -pvv + players[x].upc;
                  pv = table.pv + pvv;
                  let obj = {
                    uid: players[x].uid.toString(),
                    tbid: tbId.toString(),
                    tid: "",
                    _ir: 1,
                    cash: 0,
                    rid: table.rid,
                    mode: table.mode,
                    gt: table.gt,
                    trkid: table.tjid,
                    diff: 0,
                    upc: fChips,
                    t: "Game Lost",
                  };
                  trackClass.PlayTrack(obj, function (data) { });

                  let botCashObj = {
                    uid: getInfo.MongoID(players[x].uid),
                    tbid: tbId.toString(),
                    tjid: table.tjid,
                    _ir: players[x]._ir,
                    gameType: table.gt,
                    bv: table.bv,
                    un: players[x].un,
                    amount: Math.abs(fChips),
                    round: table.round,
                    // upc: fChips,
                    t: "Game Lost",
                    cd: new Date(),
                    totalcash: players[x].totalCash
                  }
                  logger.info('bot_cash_track-----botCashObj-----1------>', botCashObj);
                  await db.collection("bot_cash_track").insertOne(botCashObj);

                } else if (x == players.length - 1) {
                  logger.info('--------in else if---------');
                  const tableName = await getTableName(table.gt);
                  const lobbyDetail = await db
                    .collection(tableName)
                    .findOne({ _id: getInfo.MongoID(table.categoryId) });
                  let bvv = table.bv * MAX_DEADWOOD_PTS;
                  let pvv = bvv * table.ap;
                  logger.info('---pvv------>', pvv);
                  let ppv = table.pv + pvv;
                  logger.info('---ppv------>', ppv);
                  let apv = table.pv + pvv;
                  logger.info('---apv------>', apv);
                  let bonusPercentage = lobbyDetail.bonus ?? 0;
                  let commission = lobbyDetail.commission
                    ? lobbyDetail.commission
                    : 0;
                  let tds = (apv * commission) / 100;
                  logger.info('-------tds--------?', tds);
                  apv = apv - tds;
                  logger.info('----apv------->', apv);
                  let fChips = apv + players[x].upc;
                  // if (ppv > TAX_VALUE) {
                  //   let tax = (ppv * TAX) / 100;
                  //   apv = apv - tax;
                  //   let taxdata = {
                  //     uid: "admin",
                  //     tbid: tbId.toString(),
                  //     tid: "",
                  //     _ir: 0,
                  //     cash: tax,
                  //     rid: table.rid,
                  //     mode: table.mode,
                  //     gt: table.gt,
                  //     trkid: table.tjid,
                  //     diff: 0,
                  //     t: "tds from winamount",
                  //   };
                  //   trackClass.PlayTrack(taxdata, function (tdsdata) { });
                  //   let tdstrack = {
                  //     tbid: tbId.toString(),
                  //     tjid: table.tjid,
                  //     winamount: pvv,
                  //     cmsn: tds,
                  //     tds: tax,
                  //     transferd: apv,
                  //     rid: table.rid,
                  //     mode: table.mode,
                  //     gt: table.gt,
                  //     un: players[x].un,
                  //     ue: players[x].ue,
                  //     winid: getInfo.MongoID(players[x].uid),
                  //   };
                  //   trackClass.TdsTrack(tdstrack, function (tdstrc) { });
                  // }
                  let txadmn = {
                    uid: "admin",
                    tbid: tbId.toString(),
                    tid: "",
                    _ir: 0,
                    cash: tds,
                    rid: table.rid,
                    mode: table.mode,
                    gt: table.gt,
                    trkid: table.tjid,
                    diff: 0,
                    t: "tax from winamount",
                  };
                  trackClass.PlayTrack(txadmn, function (data) { });
                  let obj = {
                    uid: players[x].uid.toString(),
                    tbid: tbId.toString(),
                    tid: "",
                    _ir: 1,
                    cash: apv,
                    rid: table.rid,
                    mode: table.mode,
                    gt: table.gt,
                    trkid: table.tjid,
                    diff: 0,
                    upc: fChips,
                    t: "Game win",
                  };
                  trackClass.PlayTrack(obj, function (data) { });

                  let botCashObj = {
                    uid: getInfo.MongoID(players[x].uid),
                    tbid: tbId.toString(),
                    tjid: table.tjid,
                    _ir: players[x]._ir,
                    gameType: table.gt,
                    bv: table.bv,
                    un: players[x].un,
                    amount: Math.abs(apv),
                    round: table.round,
                    // upc: fChips,
                    t: "Game Win",
                    cd: new Date(),
                    totalcash: players[x].totalCash + Math.abs(apv)
                  }
                  logger.info('bot_cash_track-----botCashObj-----2------>', botCashObj);
                  await db.collection("bot_cash_track").insertOne(botCashObj);

                  let upData = {
                    $inc: {
                      totalcash: commonClass.RoundInt(apv, 2),
                    },
                  };
                  getInfo.UpdateUserData(players[x].uid, upData, function () { });
                }
              } else if (table.gt == "Pool" && table.tst == "RoundStarted") {
                logger.info("players.length------->", players.length);
                logger.info(
                  "x == players.length - 1----->",
                  x == players.length - 1
                );
                if (x < players.length - 1) {
                  let botCashObj = {
                    uid: getInfo.MongoID(players[x].uid),
                    tbid: tbId.toString(),
                    tjid: table.tjid,
                    _ir: players[x]._ir,
                    gameType: table.gt,
                    bv: table.bv,
                    un: players[x].un,
                    amount: table.bv,
                    round: table.round,
                    // upc: fChips,
                    t: "Game Lost",
                    cd: new Date(),
                    totalcash: players[x].totalCash
                  }
                  logger.info('bot_cash_track-----botCashObj-----3------>', botCashObj);
                  await db.collection("bot_cash_track").insertOne(botCashObj);

                } else if (x == players.length - 1) {
                  var apv = table.pv;
                  var obj = {
                    uid: players[x].uid.toString(),
                    tbid: tbId.toString(),
                    tid: "",
                    _ir: 1,
                    cash: apv,
                    rid: table.rid,
                    mode: table.mode,
                    gt: table.gt,
                    trkid: table.tjid,
                    diff: 0,
                    upc: apv,
                    t: 'Game win'
                  };
                  trackClass.PlayTrack(obj, function (data) { });

                  let botCashObj = {
                    uid: getInfo.MongoID(players[x].uid),
                    tbid: tbId.toString(),
                    tjid: table.tjid,
                    _ir: players[x]._ir,
                    gameType: table.gt,
                    bv: table.bv,
                    un: players[x].un,
                    amount: Math.abs(apv - table.bv),
                    round: table.round,
                    // upc: fChips,
                    t: "Game Win",
                    cd: new Date(),
                    totalcash: players[x].totalCash + Math.abs(apv)
                  }
                  logger.info('bot_cash_track-----botCashObj-----4------>', botCashObj);
                  await db.collection("bot_cash_track").insertOne(botCashObj);

                  let upData = {
                    $inc: {
                      totalcash: commonClass.RoundInt(apv, 2),
                    },
                  };
                  getInfo.UpdateUserData(players[x].uid, upData, function () { });
                }
                // if (x == players.length - 1) {
                //   const tableName = getTableName(table.gt);
                //   const lobbyDetail = await db
                //     .collection(tableName)
                //     .findOne({ _id: getInfo.MongoID(table.categoryId) });
                //   let bvv = table.bv * config.MAX_DEADWOOD_PTS;
                //   logger.info("bvv---------->", bvv);
                //   let pvv = bvv * table.ap;
                //   logger.info("pvv----------->", pvv);
                //   let ppv = table.pv + pvv;
                //   logger.info("pvv-----2------>", pvv);
                //   let apv = table.pv + pvv;
                //   logger.info("apv----------->", apv);
                //   let commission = lobbyDetail.commission
                //     ? lobbyDetail.commission
                //     : 0;
                //   let bonusPercentage = lobbyDetail.bonus ?? 0;
                //   logger.info("cmsn---1-------->", commission);
                //   let tds = (apv * commission) / 100;
                //   logger.info("tds------------>", tds);
                //   apv = apv - tds;
                //   logger.info("apv-----2------>", apv);
                //   let fChips = apv + players[x].upc;
                //   logger.info("fchips------------>", fChips);
                //   if (ppv > config.MIN_TAX_VALUE) {
                //     let tax = (ppv * config.TAX) / 100;
                //     apv = apv - tax;
                //     let taxdata = {
                //       uid: "admin",
                //       tbid: tbId.toString(),
                //       tid: "",
                //       _ir: 0,
                //       cash: tax,
                //       rid: table.rid,
                //       mode: table.mode,
                //       gt: table.gt,
                //       trkid: table.tjid,
                //       diff: 0,
                //       t: "tds from winamount",
                //     };
                //     trackClass.PlayTrack(taxdata, function (tdsdata) { });
                //     let tdstrack = {
                //       tbid: tbId.toString(),
                //       tjid: table.tjid,
                //       winamount: pvv,
                //       cmsn: tds,
                //       tds: tax,
                //       transferd: apv,
                //       rid: table.rid,
                //       mode: table.mode,
                //       gt: table.gt,
                //       un: players[x].un,
                //       ue: players[x].ue,
                //       winid: getInfo.MongoID(players[x].uid),
                //     };
                //     trackClass.TdsTrack(tdstrack, function (tdstrc) { });
                //   }
                //   let txadmn = {
                //     uid: "admin",
                //     tbid: tbId.toString(),
                //     tid: "",
                //     _ir: 0,
                //     cash: tds,
                //     rid: table.rid,
                //     mode: table.mode,
                //     gt: table.gt,
                //     trkid: table.tjid,
                //     diff: 0,
                //     t: "tax from winamount",
                //   };
                //   trackClass.PlayTrack(txadmn, function (data) { });
                //   // let apv = table.pv;
                //   let obj = {
                //     uid: players[x].uid.toString(),
                //     tbid: tbId.toString(),
                //     tid: "",
                //     _ir: 1,
                //     cash: apv,
                //     rid: table.rid,
                //     mode: table.mode,
                //     gt: table.gt,
                //     trkid: table.tjid,
                //     diff: 0,
                //     upc: fChips,
                //     t: "Game win",
                //   };
                //   trackClass.PlayTrack(obj, function (data) { });
                // }
              }
            }
            robotLeave(table._id.toString(), players[x].si);
          }
        }

        
        if (players.length == 0 && table.stdP.length == 0) {
          logger.info("removeRobots-------" + table._id + "-------->>>>>");
          db.collection("play_track").updateOne(
            { tbid: table._id.toString() },
            { $set: { tet: new Date() } },
            function () { }
          );

          db.collection("last_deal").deleteOne(
            { tbid: table._id.toString() },
            function () { }
          );

          db.collection("playing_table").deleteOne(
            { _id: table._id },
            function () { }
          );
          db.collection("user_cash_percent").deleteOne(
            { tableId: table._id },
            function () { }
          );
        }
      }
    );
  } catch (error) {
    logger.error("-----> error removeRobots", error);
    getInfo.exceptionError(error);
  }
};

const robotFinishTimer = ({ table, wctt }) => {
  logger.info(
    "robotPickCard--PickCardFromOpenDeck--after-----" +
    table._id +
    "-----" +
    table.turn +
    '------>>>> "robot has completed hand after picking card from thrown cards"' +
    new Date()
  );
  finishClass.Finish(
    { card: wctt.tCard },
    { tbid: table._id.toString(), si: table.turn },
    function () {
      let dCards = {
        pure: wctt.pure,
        seq: wctt.seq,
        set: wctt.set,
        dwd: wctt.dwd,
      };
      let ps = wctt.cardSum;
      logger.info(
        'robotPickCard------pfod---->>>>>"after Finish dCards: "',
        dCards
      );
      let int = commonClass.GetRandomInt(
        config.BOT_DECL_STRT,
        config.BOT_DECL_END
      );
      logger.info(
        'robotPickCard------pfod---->>>>>"after Finish int: "',
        int
      );
      // setTimeout(function () {
      //   //robot will declare in 2 sec after finish
      //   declareClass.Declare(
      //     { dCards: dCards, ps: ps },
      //     { si: table.turn, tbid: table._id.toString() }
      //   ); //robot declare after PickCardFromOpenDeck
      // }, int * 1000);
      const jobId = `${table.gt}:delayDeclare:${table._id.toString()}:${table.pi[table.turn].uid}`;
      // scheduler.queues.delayDeclare({
      //   timer: int * 1000,
      //   jobId,
      //   firstParams: { dCards: dCards, ps: ps },
      //   secondParams: { si: table.turn, tbid: table._id.toString() }
      // });
      const jobData = {
        firstParams: { dCards: dCards, ps: ps },
        secondParams: { si: table.turn, tbid: table._id.toString() },
        calling: DELAY_DECLARE
      };
      const jobOption = { delay: int * 1000, jobId };
      addQueue(jobData, jobOption);
    }
  );
}

module.exports = {
  removeRobots,
  putRobotOnSeat,
  robotTurnStarted,
  lateRobotDeclare,
  lateRobotDeclarePool,
  robotFinishTimer
};
